#!/bin/bash

# --- Bash Strict Mode: Essential for robust scripting ---
# Exits immediately if any command fails.
set -e
# Treats unset variables as errors.
set -u
# Ensures that a pipeline's return status is the last command to fail, or zero if all succeed.
set -o pipefail

# --- Global Variables and Configuration ---
# Get the absolute path of the script's directory.
SCRIPT_DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" &> /dev/null && pwd )"
# Unique log file name with timestamp.
LOG_FILE="${SCRIPT_DIR}/script_run_$(date +%Y%m%d_%H%M%S).log"

# Redirects all standard output (stdout) and standard error (stderr) to the log file
# and simultaneously displays them on the console.
exec > >(tee -a "$LOG_FILE") 2>&1

# Default values for command-line options.
TARGET=""
PORT_RANGE="1-1024"
VERBOSE_MODE=false
OUTPUT_BASE_DIR="${SCRIPT_DIR}/os_scan_results" # Default output base directory.

# --- Functions ---

# Function to perform cleanup operations when the script is interrupted (e.g., via Ctrl+C).
cleanup() {
    echo -e "\n[!] Script interrupted! Performing cleanup..."
    # Example: Remove temporary files.
    if [ -f "${SCRIPT_DIR}/temp_data_for_script.txt" ]; then
        rm -f "${SCRIPT_DIR}/temp_data_for_script.txt"
        echo "[+] Cleaned up 'temp_data_for_script.txt'."
    fi
    echo "--- Cleanup Complete. Exiting. ---"
    exit 1 # Exit with an error code to indicate abnormal termination.
}

# Trap the SIGINT signal (generated by Ctrl+C) and call the cleanup function.
trap cleanup SIGINT

# Function to greet a user.
# Usage: greet_user "Name"
greet_user() {
    local NAME="$1" # 'local' scopes the variable to the function.
    echo "Hello, $NAME! Welcome to the Advanced OS Script."
}

# Function to calculate the sum of two numbers.
# Usage: result=$(get_sum 10 20)
get_sum() {
    local NUM1="$1"
    local NUM2="$2"
    local SUM=$((NUM1 + NUM2))
    echo "$SUM" # Returns the sum by printing it to stdout.
}

# Function to execute a given command string and check its success.
# Usage: check_command_success "ls -l /etc/passwd"
check_command_success() {
    local CMD_TO_RUN="$1"
    echo "[*] Attempting to run: '$CMD_TO_RUN'"
    if eval "$CMD_TO_RUN"; then # 'eval' executes the string as a command.
        echo "[+] The command '$CMD_TO_RUN' executed successfully."
        return 0 # Success.
    else
        echo "[!] The command '$CMD_TO_RUN' failed to execute!"
        return 1 # Failure.
    fi
}

# Function to simulate an Nmap scan.
# This function demonstrates how to integrate external tools.
# Usage: simulate_nmap_scan "target.com" "80,443"
simulate_nmap_scan() {
    local TARGET_HOST="$1"
    local PORTS="$2"
    # Create a unique output directory for this scan.
    local SCAN_OUTPUT_DIR="${OUTPUT_BASE_DIR}/nmap_scans/$(date +%Y%m%d_%H%M%S)_${TARGET_HOST//./_}"
    mkdir -p "$SCAN_OUTPUT_DIR"
    echo "[*] Starting simulated Nmap scan on $TARGET_HOST:$PORTS..."
    echo "    Output directory: $SCAN_OUTPUT_DIR"

    # Simulate Nmap output and save to files.
    # In a real scenario, you'd run `nmap ... -oA "$SCAN_OUTPUT_DIR/scan_results"`.
    echo "Nmap scan report for $TARGET_HOST" > "$SCAN_OUTPUT_DIR/nmap_full.txt"
    echo "Open ports: $PORTS" >> "$SCAN_OUTPUT_DIR/nmap_full.txt"
    echo "Service details for $TARGET_HOST" > "$SCAN_OUTPUT_DIR/nmap_service.txt"
    echo "Port 22/tcp open ssh" >> "$SCAN_OUTPUT_DIR/nmap_service.txt"
    echo "Port 80/tcp open http" >> "$SCAN_OUTPUT_DIR/nmap_service.txt"

    if [ "$VERBOSE_MODE" = true ]; then
        echo "Simulating command: nmap -p $PORTS -sV -sC -oA \"$SCAN_OUTPUT_DIR/scan_results\" \"$TARGET_HOST\""
    fi

    echo "[+] Simulated Nmap scan complete. Results in '$SCAN_OUTPUT_DIR'."
}

# Function to simulate msfvenom payload generation.
# This demonstrates how to automate payload creation.
# Usage: simulate_msfvenom "10.0.0.1" "4444" "windows/meterpreter/reverse_tcp" "exe" "shell.exe"
simulate_msfvenom() {
    local LHOST_IP="$1"
    local LPORT_NUM="$2"
    local PAYLOAD="$3"
    local FORMAT="$4"
    local OUT_FILE="$5"
    local PAYLOAD_OUTPUT_DIR="${OUTPUT_BASE_DIR}/payloads"
    mkdir -p "$PAYLOAD_OUTPUT_DIR"

    echo "[*] Simulating MSFvenom payload generation..."
    echo "    LHOST: $LHOST_IP"
    echo "    LPORT: $LPORT_NUM"
    echo "    Payload: $PAYLOAD"
    echo "    Format: $FORMAT"
    echo "    Output File: ${PAYLOAD_OUTPUT_DIR}/${OUT_FILE}"

    # Simulate creation of the payload file.
    # In a real scenario, you'd run `msfvenom -p "$PAYLOAD" LHOST="$LHOST_IP" LPORT="$LPORT_NUM" -f "$FORMAT" -o "${PAYLOAD_OUTPUT_DIR}/${OUT_FILE}"`.
    echo "This is a simulated $PAYLOAD payload for $LHOST_IP:$LPORT_NUM" > "${PAYLOAD_OUTPUT_DIR}/${OUT_FILE}"
    echo "[+] Simulated payload '${PAYLOAD_OUTPUT_DIR}/${OUT_FILE}' created."
}

# Function to simulate adding cron job persistence.
# This illustrates a common post-exploitation technique.
# Usage: simulate_cron_persistence
simulate_cron_persistence() {
    local BACKDOOR_SCRIPT_NAME="system_check.sh"
    local BACKDOOR_SCRIPT_PATH="/tmp/$BACKDOOR_SCRIPT_NAME"
    # A cron job entry to run the backdoor script every minute.
    local CRON_JOB="* * * * * bash $BACKDOOR_SCRIPT_PATH # System Health Check"

    echo "[*] Simulating creation of backdoor script: $BACKDOOR_SCRIPT_PATH"
    echo '#!/bin/bash' > "$BACKDOOR_SCRIPT_PATH"
    echo 'echo "Simulated backdoor activity: $(date)" >> /tmp/backdoor_log.txt' >> "$BACKDOOR_SCRIPT_PATH"
    chmod +x "$BACKDOOR_SCRIPT_PATH"

    echo "[*] Simulating adding cron job: '$CRON_JOB'"
    # In a real scenario, you would add the job to the crontab like this:
    # (crontab -l 2>/dev/null; echo "$CRON_JOB") | crontab -
    echo "[+] Simulated cron persistence setup complete. Check /tmp/backdoor_log.txt for simulated activity."
    echo "[!] REMINDER: In a real scenario, remember to clean up: 'rm $BACKDOOR_SCRIPT_PATH' and remove the cron job from 'crontab -e'."
}


# --- Main Script Logic ---

echo "--- Script started at $(date) ---"

# --- Argument Parsing with getopts ---
# Parses command-line options.
#   : at start: Enables silent error reporting for custom handling.
#   t:, p:, o:: options requiring arguments.
#   v: a flag option (no argument).
while getopts ":t:p:vo:" opt; do
    case $opt in
        t) # Target host/IP
            TARGET="$OPTARG"
            ;;
        p) # Port range (e.g., "80,443" or "1-1024")
            PORT_RANGE="$OPTARG"
            ;;
        v) # Verbose mode flag
            VERBOSE_MODE=true
            ;;
        o) # Custom output base directory
            OUTPUT_BASE_DIR="$OPTARG"
            ;;
        \?) # Handles invalid options.
            echo "[!] Error: Invalid option: -$OPTARG" >&2
            exit 1
            ;;
        :) # Handles options that require an argument but didn't receive one.
            echo "[!] Error: Option -$OPTARG requires an argument." >&2
            exit 1
            ;;
    esac
done
# Shifts positional parameters so that non-option arguments can be processed.
shift "$((OPTIND - 1))"

# --- Initial Validation ---
# Ensure a target is provided.
if [ -z "$TARGET" ]; then
    echo "[!] Usage: $0 -t <target_IP/hostname> [-p <port_range>] [-v] [-o <output_directory>]" >&2
    echo "    Example: $0 -t example.com -p 22,80,443 -v -o my_custom_results" >&2
    exit 1
fi

echo "[*] Configuration Summary:"
echo "    Target: $TARGET"
echo "    Ports: $PORT_RANGE"
echo "    Verbose Mode: $VERBOSE_MODE"
echo "    Output Base Directory: $OUTPUT_BASE_DIR"

# Create the base output directory if it doesn't exist.
mkdir -p "$OUTPUT_BASE_DIR"

# --- Demonstrate core Bash features (briefly, as covered in previous days) ---

echo ""
echo "--- Basic Bash Features Demo ---"
# Variables and Input.
MY_NAME="Artem"
MY_AGE=20
echo "My name is $MY_NAME and I'm $MY_AGE years old."

# Numerical and String Comparisons.
NUM1=10
NUM2=20
if (( NUM1 < NUM2 )); then
    echo "$NUM1 is less than $NUM2"
elif (( NUM1 == NUM2 )); then
    echo "$NUM1 is equal to $NUM2"
else
    echo "$NUM1 is greater than $NUM2"
fi

STR1="bash"
STR2="scripting"
if [[ "$STR1" == "bash" && "$STR2" != "python" ]]; then
    echo "It's certainly bash and not python!"
fi

# Loops.
echo ""
echo "--- Loop Demos ---"
for FRUIT in "apple" "banana" "orange"; do
    echo "I have this fruit: $FRUIT"
done

for I in {1..3}; do
    echo "Number $I"
done

COUNT=0
while (( COUNT < 3 )); do
    echo "Counter: $COUNT"
    COUNT=$((COUNT + 1))
done

# File operations demo.
echo ""
echo "--- File Operations Demo ---"
touch "${SCRIPT_DIR}/file_a.txt" "${SCRIPT_DIR}/file_b.log" "${SCRIPT_DIR}/file_c.txt"
echo "Created sample files in ${SCRIPT_DIR}: file_a.txt, file_b.log, file_c.txt"
for FILE in "${SCRIPT_DIR}"/*.txt; do
    echo "Found text file: $FILE"
done
rm "${SCRIPT_DIR}"/*.txt "${SCRIPT_DIR}"/*.log
echo "Removed sample files."


# --- Function Calls ---
echo ""
echo "--- Function Demos ---"
greet_user "Community" # Calling a function with an argument.

SUM_RESULT=$(get_sum 25 15) # Capturing function output.
echo "The sum of 25 and 15 is: $SUM_RESULT"

# Demonstrate command success check.
check_command_success "ls /etc/passwd"
check_command_success "cat /nonexistent/file_12345"


# --- Offensive Security Tool Simulations ---
echo ""
echo "--- Offensive Security Tool Simulations ---"

# Simulate Nmap scan using the parsed TARGET and PORT_RANGE.
simulate_nmap_scan "$TARGET" "$PORT_RANGE"

# Simulate Msfvenom payload generation with example parameters.
simulate_msfvenom "10.0.0.10" "4444" "linux/x64/meterpreter/reverse_tcp" "elf" "reverse_shell.elf"

# Simulate Cron persistence setup.
simulate_cron_persistence

echo "--- Script finished successfully at $(date) ---"
